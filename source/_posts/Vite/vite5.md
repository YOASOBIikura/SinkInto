---
title: vite5
date: 2024-11-10 15:00:52
categories:
  - vite
tags:
  - 性能优化
---

## 性能优化总览

我们常说的性能优化到底是什么东西？它包括很多方面，主要分为:

### 开发时态的构建速度优化: dev / start 敲下的瞬间到呈现结果要占用多少时间

  - webpack 在这方面下的功夫是很多的：cache-loader(两次构建的源码没有产生变化，则直接使用缓存不去调用loader)，thread-loader通过开启多个线程去构建等等方法
  - vite 是按需加载，所以用需要在这方面做太多优化

### 页面性能指标：这和我们写代码有关

  - 首屏渲染时长: fcp(first content paint), (first content paint -> 页面中第一个元素的渲染时长)
    - 懒加载: 需要我们去写代码实现
    - http优化: 协商缓存 强缓存
        - 强缓存: 服务端给响应头追加一些字段(expires), 客户端会记住这些字段，在expires(截止失效时间)没有到达之前，无论你怎么刷新页面，浏览器都不会重新请求页面，而是从缓存里面取
        - 协商缓存: 是否使用缓存需要与后端商量一下，当服务端给我们打上协商缓存标记以后，客户端在下次刷新页面需要重新请求时会发送一个协商请求给到服务端，服务端如果说需要变化则会相应具体的内容，如果服务端觉得没变化则会相应304
  - 页面最大元素的一个时长: lcp(largest content paint)
  等等指标

### js逻辑:

  - js计时器的开关释放，严重的会导致内存溢出页面卡顿
  - js内部的监听器等 同理
  - 对浏览器渲染原理的理解，由于浏览器是16.6ms去刷新一次(执行js逻辑 重排 重绘....)，假设我们的一个js的执行逻辑超过了16.6ms就会引起页面掉帧卡顿
  - 常用的防抖节流函数效率太低，应该使用最佳实践的lodash.js现成的工具包括数据量太大的list遍历同样也可以

### css:

  - 关注继承属性: 能继承的旧的旧不要重复写了
  - 尽量避免嵌套过深

### 构建优化：vite(rollup) webpack

  - 优化体积: 压缩， treeshaking, 图片资源压缩， cdn加载， 分包......

