---
title: Selector
date: 2024-07-11 11:08:27
categories:
  - css
tags:
  - Selector
---

## 基本选择器

通配符选择器
```
*{
    margin:0;
    padding:0;
}
```

元素选择器
```
body{
    margin:0;
    padding:0;
}
```

类选择器
```
.list{
    margin:0;
    padding:0;
}
```

ID选择器
```
#list{
    margin:0;
    padding:0;
}
```

后代选择器
```
.list li{ 
    margin:0;
    padding:0;
}
```

---

## 基本选择器的扩展

子元素选择器
```
.list > li{ 
    margin:0;
    padding:0;
}
```
会匹配到直接后代，而不会去匹配深层子节点

相邻兄弟选择器
```
.list + .asd{ 
    margin:0;
    padding:0;
}
```
会匹配到后面紧跟着的asd类兄弟元素

通用兄弟选择器
```
.list ~ li{ 
    margin:0;
    padding:0;
}
```
会匹配到后面所有所有指定的兄弟元素，而不需要紧跟

分组选择器
```
h1,h2,h3{ 
    margin:0;
    padding:0;
}
```
这里的逗号又称为结合符

---

## 属性选择器

存在和值属性选择器
`(选择器)[attr]` 表示含有attr属性的选择器

`(选择器)[attr=val]` 表示含有attr属性值等于val的选择器

`(选择器)[attr~=val]` 表示含有attr属性值以列表形式给出，中间空格分隔如果其中包含有一个val属性值的选择器

`(选择器)[attr|=val]` 表示含有attr属性值是val或者是val-两类的选择器

`(选择器)[attr^=val]` 表示含有attr属性值是val或是以val开头的选择器

`(选择器)[attr$=val]` 表示含有attr属性值是val或是以val结尾的以选择器

`(选择器)[attr*=val]` 表示含有attr属性值只要包含有val的以选择器

---

## 伪类选择器

### 链接伪类选择器

该选择器只能用于超链接标签，对其他标签无效

`(选择器):link` 表示超链接还没访问的时候

`(选择器):vidited` 表示超链接已访问的时候

`(选择器):target` 表示点击后的id是URI片段的元素

### 动态伪类选择器

`(选择器):hover` 鼠标悬浮在选择器元素上

`(选择器):active` 表示被鼠标点击激活的元素

当选择器是连接的时候，一定要遵守LVHA规则，即一定要确保链接伪类选择器需要在动态伪类选择器之前，不然链接伪类选择器会覆盖掉所有的链接元素
特别注意visited选择，该选择器只有color,background-color,border-color三个属性可以被应用。

### 表单伪类选择器

`(选择器):enabled` 匹配可编辑的表单元素

`(选择器):disable` 匹配被禁用的表单元素

`(选择器):checked` 匹配被选中的表单元素

`(选择器):focus` 匹配获得聚焦的表单元素

### 结构性伪类选择器

`(选择器):nth-child(index)` 匹配选择器的相应索引的元素

`(选择器):first-child` 匹配选择器第一个孩子

`(选择器):last-child` 匹配选择器最后一个孩子

`(选择器):nth-last-child(index)` 匹配选择器倒数索引的孩子

`(选择器):only-child` 匹配选择器的唯一孩子

`(选择器):nth-of-type(index)` 匹配选择器该类型的相应索引的元素

`(选择器):first-of-type` 匹配选择器第一个该类型的元素

`(选择器):last-of-type` 匹配选择器最后一个该类型的元素

`(选择器):nth-last-type(index)` 匹配选择器倒数该索引类型的元素

`(选择器):only-of-type` 匹配选择器唯一一个该类型的元素

1. 他们之间有一个重要的区别就是nth-of-type是以元素为中心，而nth-child则是以位置为中心
2. first-child主要会要求第一个孩子并且还需要满足元素选择器的类型判断标准
   而first-of-type则主要匹配第一个该元素，不会强制想异的元素位置

### 伪元素选择器

`(选择器)::after` 在选择器之后生成一个设置css样式的元素

`(选择器)::before` 在选择器之前生成一个设置css样式的元素

`(选择器)::firstLetter` 匹配选择器中的第一个字符元素

`(选择器)::firstLine` 匹配选择器中的第一行字符元素

`(选择器)::selection` 匹配选择器中的选中标记之后的元素

## CSS声明的优先级

在css声明中通过其特殊性来进行优先级的判定，特殊性值的表述通常为四个值的表示如0,0,0,0
而一个选择器声明的特殊性如下：
    1. 对于选择器中给定的ID属性值，加0,1,0,0
    2. 对于选择器中给定的类属性，属性的选择或者伪类属性，加0,0,1,0
    3. 对于选择器中给定的各个元素和伪元素，加0,0,0,1
    4. 通配符选择器的特殊性为0,0,0,0
    5. 结合符的特殊性没有贡献不加值
    6. 内联声明的特殊性都是1,0,0,0 如`<div style=""></div>`
    7. 继承没有特殊性

    其中特殊性的贡献的增减是不会进位的，前位的特殊性不论大小都比后位的特殊性更大，这也就导致在多个匹配规则中
    对同一个选择器元素作用相互冲突时，特殊性越大的选择器更占优势

重要声明，如果某个选择需要声明为重要声明可以在声明的属性之后的分号放置`!important`来进行标记。该标记并不会
贡献特殊值，但是会和非重要属性进行区分，如果在与非重要属性冲突时，胜出的是重要声明。

继承虽然没有特殊性，甚至连0特殊性都没有，0特殊性要比无特殊性来得强。

权重:
     读着的重要声明
     创作人员的重要声明
     创作人员的正常声明
     读者的正常声明
     用户代理的声明

一般层叠样式表的优先级由权重来显示，这些通常来源于创作人员，用户以及用户代理。并且每
个来源都有自己的css规则。各个规则依照权重来进行显示，权重越高自然会优先显示。在每套
规则中进一步确定显示规则:
    1. 找出所有相关规则，如果这些规则包含同一个选择器
    2. 计算声明的优先级
          先按来源进行排序
          再按照选择器的特殊性进行排序
          同特殊性时通过顺序优先级进行排序

