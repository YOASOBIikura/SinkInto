---
title: sol-01
date: 2024-12-10 10:19:49
categories:
  - Solidity
tags:
  - 值传递与引用传递
---

# 变量存储

一般在合约的变量存储中遵循以下规则，变量的存储分为Storage,Memory,CallData这三个类型。

在赋值的过程中，不管storage -> memory还是memory -> storage中都会创建一个全新的副本，修改赋值后的副本不会影响原来的内容。

首先是CallData这个类型，该类型与memory类型类型同样都是存储在内存中，但是只用来存储函数接受的外来参数。并且只能读不能去修改。

然后是Memory类型，在函数中的一些值传递的局部变量会存储在memory中，在合约中常见的值传递类型有: 布尔类型、整形、定长浮点型、地址类型、
定长/变长字节数组、地址字面量常数、有理数和整数字面常数、字符串字面常数、十六进制字面常数、枚举类型、函数类型。即使他们之前是存储在合
约的状态变量当中，赋值到局部变量中依然是拷贝一个副本到memory中去。修改这个副本是不会影响到状态变量的。除非直接使用合约状态变量进行强
制更改。

最后是Storage类型，该类型通常存储在以太坊插槽中，如果频繁进行改动会极大消耗Gas，通常存储在storage中都是复杂类型，即引用传递类型的变
量如:数组、结构体、映射。其中映射类型如果赋值到局部变量中会强制要求指定存储在Storage中，不然就会报错不通过编译。而数组和结构体可以指
自定义定局部变量定义在memory或者storage中，但是这里需要注意，如果是在memory则是单独复制一份到内存中修改该拷贝不会影响原值，但是如
果表明了是在storage中则传递的是引用，修改该值会导致原值被改变。当然其中还有例外情况，就是如果结构体中含有映射结构，则它赋值到局部变量
时也只能强制指定到storage中，不然就会编译报错。
