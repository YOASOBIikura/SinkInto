---
title: React-06
date: 2024-12-29 14:51:17
categories:
  - React
tags:
  - 合成事件
---

## React中合成事件的处理原理
绝对不是基于addEventListener单独做的事件绑定，React中的合成事件大都是基于事件委托处理的
- React17及以后版本都是通过委托给#root容器[捕获和冒泡都做了委托]
- React17版本以前都是通过委托给document容器[并且只做了冒泡阶段的委托]
- React16中是在document在事件中把捕获与冒泡一起做了
- 对于没有事件传播机制的事件，才是单独做的事件绑定

在组件渲染的时候，如果发现JSX元素属性中有 onXxx 这样的属性，不会给当前元素直接做事件绑定，只是把绑定的方法赋值给了相关元素的属性

然后对#root这个容器做了事件绑定(捕获和冒泡)，进而在给#root绑定方法中，把之前给元素设置的onXxx等属性绑定的方法在相应阶段进行执行即可

执行即使在捕获阶段在#root容器中，通过e.path反转执行onXxxCapture执行达到捕获的效果，而执行onXxx等只用通过元e.path执行即可

React16中，关于合成事件对象的处理中基于"事件对象池1"，做了一个缓存机制；但是React17去掉了这个机制
- 每次事件触发的时候，如果传播到了委托的元素上，在委托方法中，我们会首先对内置事件对象做统一的处理，生成合成事件对象。为了防止每一次都是重新创建新的合成事件对象，所以设置了一个对象缓存池
- 当事件触发时，获取到事件操作的相关信息后，我们从事件对象池中获取存储的合成事件对象，把信息赋值给相关的成员！
- 等待本次操作结束后，把合成事件对象中的成员信息都清空掉，再放入事件对象池中
