---
title: ValueStorage
date: 2025-05-20 15:52:28
categories:
  - contract
tags:
  - store
---


## Memory中的存储

在 memory 中并非所有数据的第一个字节都存储数据的长度。这个说法只适用于动态大小的数组（如 bytes, string, uint[] 等）在 memory 中的布局。

以下是 memory 中不同数据类型的存储方式概览：

1. 动态大小数组 (bytes, string, T[]，其中 T 是任意类型)：

    第一个 32 字节（一个字）：存储数组的元素数量（长度）。
    后续的字：存储数组的实际元素。每个元素会占用一个或多个 32 字节的字，并按照类型进行填充或对齐。
    例如：

    bytes memory myBytes = "hello";：第一个字存储 5（长度），第二个字存储 0x68656c6c6f00...00。
    uint[] memory myUintArray = new uint[](3);：第一个字存储 3（长度），接下来的三个字分别存储 myUintArray[0]、myUintArray[1]、myUintArray[2] 的值。

2. 固定大小数组 (T[N])：

    固定大小的数组在 memory 中不存储长度。它们的长度在编译时是已知的。
    它们会直接从内存指针指向的地址开始，按照元素类型连续存储元素。每个元素会占用 32 字节的倍数（即使是 uint8 也会占用一个完整的 32 字节槽位）。
    例如：

    uint[3] memory fixedArray;：fixedArray[0] 存储在起始地址，fixedArray[1] 存储在起始地址 + 32 字节，fixedArray[2] 存储在起始地址 + 64 字节。没有额外的长度字段。

3. 结构体 (struct)：

    结构体在 memory 中的布局是其成员变量的连续存储。每个成员变量会根据其类型占据 32 字节的倍数，并进行适当的对齐。
    不会有额外的长度字段，除非结构体内部包含动态大小的数组。

4. 值类型 (Value Types) 如 uint, bool, address 等：

    它们在 memory 中通常直接占据一个完整的 32 字节的槽位。
    不会有额外的长度字段。
总结：
只有当你在 memory 中处理动态大小的数据结构时（如 bytes, string 或 T[] 类型的动态数组），第一个 32 字节才会用来存储它们的长度。对于固定大小的数据类型，例如固定大小数组或单独的值类型，是没有这个长度字段的。

理解这些内存布局对于在 Solidity 中进行低级内存操作（例如使用 assembly）非常重要，因为它直接影响你如何读取和写入内存中的数据。


## storage中的存储

在 storage 中，数据的存储方式与 memory 有很大的不同，并且更加复杂，旨在优化 Gas 成本和存储效率。在 storage 中，并非所有数据的第一个字节都存储长度，甚至不是第一个槽位。
storage 是一个持久化的键值存储，你可以把它想象成一个巨大的 mapping(uint256 => uint256)，每个 uint256 的键代表一个存储槽的地址，每个 uint256 的值是该槽中存储的数据。

以下是 storage 中不同数据类型的存储方式概览：

1. 值类型 (Value Types)
    uint, bool, address, bytes1 到 bytes32 等。
    它们会尽可能地打包 (pack) 到同一个存储槽中，以节省 Gas。
    打包规则是：如果多个值类型（或固定大小的字节数组）的总大小不超过 32 字节，它们就会被存储在同一个 32 字节的存储槽中。
    不存储长度。例如，uint8 a; uint8 b; 会被打包到一个槽中。

2. 固定大小数组 (T[N])
    例如 uint[5] fixedArray;
    固定大小的数组会从其声明的存储槽开始，连续地占用 N 个存储槽。
    每个元素都会占据一个完整的 32 字节槽位（即使是 uint8 元素）。
    不存储长度。数组的长度在编译时已知。

3. 结构体 (struct)
    结构体的成员会像单独的变量一样，从结构体声明的存储槽开始，按照成员变量的类型和打包规则进行存储。
    如果结构体成员可以被打包，它们会被打包。
    不存储结构体本身的长度。结构体的布局由其成员决定。

4. 动态大小数组 (bytes, string, T[])
    这是最复杂的部分，也是你问题关注的重点。对于 bytes 和 string (它们在内部都是字节数组) 以及动态数组 T[]：

    a. 短数据 (Short Data) - 长度小于等于 31 字节：
       如果 bytes 或 string 的长度小于等于 31 字节，它们会和长度一起被打包存储在声明它们的那个 32 字节的存储槽中。
       具体布局是：
       数据的实际字节存储在槽的 低位部分（右侧）。
       数据的长度 L 乘以 2，存储在槽的 最高位字节（左侧）。
       例如，一个长度为 L 的 bytes 数据，它会存储为 data_bytes << 8 | (L * 2)。
       注意： 这里的长度是存储在同一个槽的最高字节，而不是第一个字或单独的第一个字节。

    b. 长数据 (Long Data) - 长度大于 31 字节：

       如果 bytes 或 string 的长度大于 31 字节，或者是一个动态数组 T[]（无论长度多少），它们在 storage 中的存储方式非常特殊：

    声明它们的那个存储槽（例如，如果你声明了 bytes public myBytes;，那么 myBytes 变量本身所在的槽）会存储一个 32 字节的值，这个值是 数据的长度乘以 2 加 1。
    实际的数据内容 不存储在这个槽中。相反，它存储在通过 Keccak-256 哈希计算出的另一个存储槽 中。具体来说，数据存储在 keccak256(p) 处，其中 p 是 bytes/string/动态数组变量本身的存储槽位。
    这种设计允许动态数据的大小不固定，且不会影响其后的其他状态变量的存储布局。
    例如：

    如果你有一个 bytes public myLongBytes;，假设它被分配到存储槽 0x0。
    槽 0x0 将存储 (length * 2) + 1。
    myLongBytes 的实际数据将从 keccak256(0x0) 开始的连续存储槽中读取。

5. 映射 (mapping)
    映射的数据不存储在声明它的存储槽中。
    映射的键和值实际上是通过计算 keccak256(key + map_slot) 来确定其存储位置的。
    不存储长度，因为映射是稀疏的，且理论上可以无限大。

总结 storage
在 storage 中，只有动态大小的字节数组 (bytes 和 string) 在短数据模式下会将长度与数据打包存储在同一个槽中（且长度在最高字节）。
在长数据模式下，动态数组的长度存储在其声明的槽中，但实际数据存储在通过哈希计算得出的地址。
其他类型（值类型、固定大小数组、结构体）在 storage 中通常不存储长度，它们的长度在编译时是已知的，或者通过打包规则隐式确定。

## 在内联汇编中使用的特例

对于内存中的动态类型，一般情况下，当你在汇编中直接操作它们的“内容”时，你获得的指针通常是指向实际数据而非长度槽的。

让我们来看一下 Solidity 内存中几种动态类型和固定大小类型的一般布局规则：

1. bytes 和 string (动态字节数组和字符串)

    内存布局：
    第一个 32 字节槽： 存储其长度 (以字节为单位)。
    紧随其后的槽： 存储实际的字节数据，以 32 字节字对齐。如果数据不足 32 字节，会填充到 32 字节。
    汇编操作时：
    当你在 Solidity 高级语言中声明 bytes memory myBytes; 并将其作为参数传递给一个内联汇编块，或者通过 mload 操作一个 bytes 变量时，通常情况下，你得到的内存地址会是指向长度槽的地址。
    然而，编译器在生成像我们之前分析的切片代码时，会很智能地处理。 如果它需要操作数据的起始位置，它会内部计算 _bytes + 0x20，并将这个计算后的地址作为“实际数据起始地址”传递给负责数据复制的汇编代码。
    所以，在那个特定的切片汇编代码中，_bytes 被假定为已经跳过长度槽，指向实际数据开始的地方。这是编译器在背后做的事情，以简化数据操作的逻辑。

2. 动态数组 (例如 uint[] memory myArr)

    内存布局：
    第一个 32 字节槽： 存储数组的长度 (以元素数量为单位)。
    紧随其后的槽： 存储数组元素。每个元素都占用一个完整的 32 字节槽，即使是 uint8 也会占用 32 字节。
    汇编操作时：
    与 bytes 和 string 类似，如果你直接操作 uint[] memory myArr，通常你得到的指针会是指向长度槽的地址。
    要访问实际的第一个元素，你需要从这个指针偏移 32 字节 (0x20)。

3. 结构体 (Structs) (如果包含动态成员)

    内存布局： 结构体在内存中是连续分配的，成员按声明顺序依次排列。
    如果结构体中包含动态类型成员（如 bytes、string 或动态数组），那么在结构体内部，这些动态成员的槽位存储的不是它们本身的数据，而是指向它们实际数据在内存中存储位置的指针 (偏移量)。

    例如：
    Solidity

    struct MyStruct {
        uint255 id;
        string name; // 动态类型
        uint[] values; // 动态类型
    }
    MyStruct memory s;
    s 在内存中会分配多个 32 字节槽：
    第一个槽是 s.id 的值。
    第二个槽是 s.name 的内存偏移量 (指向 name 实际数据开始的位置)。
    第三个槽是 s.values 的内存偏移量 (指向 values 实际数据开始的位置)。 而 s.name 和 s.values 的实际数据会存储在内存中其他的位置，并且它们各自的第一个 32 字节槽会存储自己的长度。
    
总结：
在内存中，所有动态大小的类型 ( bytes, string, 动态数组) 的第一个 32 字节槽都用于存储其长度。 这是它们的标准内存布局。
当你在高级 Solidity 代码中直接引用这些类型时，其变量本身代表的内存地址就是这个长度槽的地址。
但在特定的汇编代码片段（如我们分析的切片函数）中，汇编代码可能接收的是一个已经“预处理”过的指针，这个指针已经指向了实际数据的起始位置（即跳过了长度槽）。这是因为编译器在生成汇编时，为了优化或简化后续操作，可能会进行这种地址的计算和传递。
所以，不能一概而论地说“都不用考虑前 32 个字节”。你需要根据具体的上下文和操作，判断你当前正在使用的内存指针是指向长度槽，还是已经偏移到数据本身。在编写低级汇编代码时，理解这些内存布局规则至关重要。
