---
title: AssemblerMemory
date: 2024-08-01 09:52:24
categories:
  - assembly
tags:
  - memory
---

EVM在运行链上合约时会动态的给每个正在运行的合约动态分配内存。但是动态分配的内存并不是无限的，
而是根据合约的具体需求来进行分配的，其分配的特点如下：
                                            1. 动态性：内存是按需分配的，合约执行过程中，随着变量的创建、数组的扩展等操作，内存会不断增长。
                                            2. 临时性：分配的内存仅在合约执行期间有效。一旦合约执行完毕，分配的内存就会被释放。
                                            3. 成本累计：在EVM上，对内存的读写操作会消耗gas，因此频繁的内存操作会增加交易的成本，这也间接限制了用户对内存操作的空间。
                                
EVM提供了多种类型的存储方式，每种都有不同的特性和用途：
a. 存储(storage): 用于存储合约的状态变量，数据是持久化的，会永久保存在区块链上。
b. 内存(memory): 用于存储函数的参数、局部变量、动态数组等临时数据。
c. 调用数据(calldata): 用于存储函数调用时的参数。
d. 栈(stack): 用于存储 EVM 执行指令时的临时数据。

## 内存操作

在solidity合约运行分配的内存中，通常会操作一些内存的插槽地址，其一个插槽是32字节其分布如下:

a. 0x00 ~ 0x1f、0x20 ~ 0x3f(共64字节):这段内存空间是哈希方法的暂存空间，就是如果当合约在进行哈希运算时会将运算结果临时存放在这段空间中，使用存在风险
                                     因为如果强行使用这段空间进行值的存放，而后在合约运行到其他地方的时候进行了哈希运算之后，这段存储空间之前的值就
                                     会被哈希运算的值给覆盖掉。所以并不是不能使用，但是在使用时你一定要清楚自己要干什么，这个程序运行中在这段空间的
                                     值被返回之前都不能进行哈希运算🙅🏻‍♀️🙅🏻‍♀️🙅🏻‍♀️🙅🏻‍♀️，这才能在一定程度上防止意外发生。
b. 0x40 ~ 0x5f(共32字节):当前分配的内存大小(又名自由内存指针):这段内存空间默认指向的是0x80地址，也就是空闲内存空间的起始地址。那为什么不能直接使用0x80
                        这段内存空间呢？注意，之所以使用0x40这个空闲内存空间地址是因为空闲内存空间是会变的，当使用汇编调用时如果合约之前的操作进行过其
                        他内存空间的分配比如变量定义或者函数参数包含memory等，都可能会使自由内存指针发生改变，比如过在进行汇编操作之前刚好定义了一个内
                        存变量数据那么它会暂用两个32字节的空间：
                        第一个32字节空间0x80 ~ 0x9f(共32字节): 存储变量数据的长度
                        第二个32字节空间0xa0 ~ 0xbf(共32字节): 存储真正的变量数据
                        后一个32字节空间0xc0: 也就是新的自由内存的起点
                        如果贸然直接使用0x80则会覆盖掉之前定义的变量，而现在你想使用的其实是0xc0这段地址才对，自由内存指针就是帮我们记录这个东西的。它
                        又被叫做使用的内存大小，如果一直指向自由空闲内存，而之前的内存都是合约使用的内存那此时指向的内存地址确实可以代表被使用内存大小。
c. 0x60 ~ 0x7f(共32字节):0插槽，零槽用作动态内存数组的初始值，并且永远不应写入。言简意赅，不能操作这段内存空间。

可参考地址:
https://blog.csdn.net/weixin_39430411/article/details/124370676?spm=1001.2014.3001.5506
https://blog.csdn.net/weixin_39430411/article/details/124376961

